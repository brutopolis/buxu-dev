<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Billboard 360° + Camera-relative Movement + Colisão 3D</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.js"></script>
  <style>body{margin:0;background:#222;display:flex;align-items:center;justify-content:center;height:100vh}</style>
</head>
<body>
<script>
// world.js - biblioteca completa

function world_new() {
  const DIRS = [360,45,90,135,180,225,270,315];
  const STATE_ANGLE_OFFSETS = { idle: 90, run: 90, use: 0 };
  const RUN_FRAMES = 5;
  const USE_FRAMES = 3;
  const FRAME_INTERVAL = 120;
  const GRAVITY = 0.6;
  const GROUND_Y = -40;

  const world = {
    cubes: [],
    creatures: [],
    images: { player: {} },
    lastAnimTime: 0,

    // ---------------------------
    // API
    // ---------------------------
    new_cube(pos, size) {
      this.cubes.push({ pos, size });
    },

    new_creature(opts) {
      const ent = {
        position: opts.position.copy(),
        size: opts.size || createVector(40,80,40),
        state: opts.state || "idle",
        frame: 0,
        rotationIndex: 2,
        lastFacingIndex: 2,
        vel: createVector(0,0,0),
        npc: opts.npc || false,
        dirVec: opts.dirVec || createVector(0,0,0),
        speed: opts.speed || 0,
        spawnPos: opts.spawnPos || null,
        targetPos: opts.targetPos || null,
        traveling: opts.traveling || false,
        arrivedAt: 0,
        respawnDelay: opts.respawnDelay || 1200,
        startDelay: opts.startDelay || 0,
        _lastAnimTime: millis()
      };
      this.creatures.push(ent);
      return ent;
    },

    render() {
      background(28);
      orbitControl();

      // chão
      push();
      rotateX(HALF_PI);
      noStroke();
      fill(200);
      plane(6000,6000);
      pop();

      // cubos
      for (let c of this.cubes){
        push();
        translate(c.pos.x, c.pos.y, c.pos.z);
        noStroke();
        box(c.size.x, c.size.y, c.size.z);
        pop();
      }

      // update + render creatures
      for (let ent of this.creatures){
        this.updateCreature(ent);
        const sprite = this.safeSpriteAt(ent.state, ent.frame, ent.rotationIndex);
        this.drawBillboard(ent.position, sprite, 96, 96);
      }
    },

    // ---------------------------
    // Internals
    // ---------------------------
    updateCreature(ent) {
      // gravidade
      ent.vel.y += GRAVITY * (deltaTime/16.666);
      ent.position.y += ent.vel.y * (deltaTime/16.666);
      this.resolveVerticalCollision(ent);

      // usa movimento externo (definido em draw para o player) se houver
      let moveVec = (ent._inputMoveVec) ? ent._inputMoveVec.copy() : createVector(0,0,0);

      // NPC movimentação (chega -> idle; só volta a run quando receber novo destino)
      if (ent.npc) {
        if (ent.traveling) {
          // garante que o estado seja 'run' enquanto viaja
          ent.state = 'run';
          const mv = p5.Vector.mult(ent.dirVec, ent.speed * (deltaTime/16.666));
          ent.position.add(mv);
          moveVec = ent.dirVec.copy();

          // chegou no destino
          if (ent.targetPos && p5.Vector.sub(ent.targetPos, ent.position).mag() < 6) {
            ent.traveling = false;
            ent.arrivedAt = millis();
            // entra em idle ao chegar
            ent.state = 'idle';
            ent.frame = 0;
          }
        } else {
          // está idle — aguarda novo destino
          ent.state = 'idle';
          ent.frame = 0;

          // depois de respawnDelay, gera um novo objetivo aleatório ao redor do spawn/posição
          if (ent.arrivedAt && millis() - ent.arrivedAt > ent.respawnDelay) {
            const base = (ent.spawnPos) ? ent.spawnPos.copy() : ent.position.copy();
            const newTarget = createVector(base.x + random(-200,200), base.y, base.z + random(-200,200));
            ent.targetPos = newTarget;
            ent.dirVec = p5.Vector.sub(ent.targetPos, ent.position).normalize();
            ent.traveling = true;
            ent.arrivedAt = 0;
            ent.state = 'run';
          }
        }
      } else {
        // jogador: aplica movimento de input (se houver) aqui, com colisão
        if (moveVec && moveVec.mag() > 0.001) {
          ent.state = 'run';
          // aplica escala de tempo para movimento suave
          const scaled = p5.Vector.mult(moveVec, (deltaTime/16.666));
          const next = p5.Vector.add(ent.position, scaled);
          if (!this.collides3D(next, ent.size)){
            ent.position = next;
          }
        } else {
          // sem input
          ent.state = 'idle';
        }
      }

      // atualiza rotação apenas para NPCs ou quando houve input externo (player)
      if (ent.npc || (ent._inputMoveVec && ent._inputMoveVec.mag() > 0.001)) {
        // para facing usamos o vetor de movimento não escalado (direção)
        const faceVec = (ent.npc) ? moveVec.copy() : ent._inputMoveVec.copy();
        ent.rotationIndex = this.computeRotationIndexFor(faceVec, ent.state, ent);
      }

      // animação (timer por entidade)
      if (!ent._lastAnimTime) ent._lastAnimTime = 0;
      if (millis() - ent._lastAnimTime > FRAME_INTERVAL) {
        ent._lastAnimTime = millis();
        if (ent.state === "run"){
          ent.frame = (ent.frame + 1) % RUN_FRAMES;
        } else {
          ent.frame = 0;
        }
      }

      // se está idle, aplica offset de idle na direção do último movimento
      if (ent.state === "idle") {
        const offsetDeg = STATE_ANGLE_OFFSETS.idle || 0;
        const offsetSteps = Math.round(offsetDeg / 45) % DIRS.length;
        let idx = (ent.lastFacingIndex || 2) + offsetSteps;
        ent.rotationIndex = (idx + DIRS.length) % DIRS.length;
      }

      // limpa o vetor de input para não vazar para o próximo frame
      if (ent._inputMoveVec) delete ent._inputMoveVec;
    },

    safeSpriteAt(state, frame, rotIndex) {
      const states = this.images.player;
      if (!states[state]) return this.createPlaceholder(96,96);
      if (!states[state][frame]) return this.createPlaceholder(96,96);
      const img = states[state][frame][rotIndex];
      if (!img) return this.createPlaceholder(96,96);
      return img;
    },

    createPlaceholder(w,h){
      const g = createGraphics(w,h);
      g.clear();
      g.fill(255,0,255);
      g.rect(0,0,w,h);
      g.fill(255);
      g.textAlign(CENTER,CENTER);
      g.text("no img", w/2, h/2);
      return g;
    },

    collides3D(pos, size){
      const half = {x:size.x/2, y:size.y/2, z:size.z/2};
      for (let c of this.cubes){
        const halfC = {x:c.size.x/2, y:c.size.y/2, z:c.size.z/2};
        if (pos.x + half.x > c.pos.x - halfC.x &&
            pos.x - half.x < c.pos.x + halfC.x &&
            pos.y + half.y > c.pos.y - halfC.y &&
            pos.y - half.y < c.pos.y + halfC.y &&
            pos.z + half.z > c.pos.z - halfC.z &&
            pos.z - half.z < c.pos.z + halfC.z){
          return true;
        }
      }
      return false;
    },

    drawBillboard(pos, img, w, h){
      const cam = _renderer._curCamera;
      const dx = cam.eyeX - pos.x;
      const dz = cam.eyeZ - pos.z;
      const yaw = atan2(dx, dz);

      const gl = (_renderer && _renderer.GL) ? _renderer.GL : null;
      if (gl){
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthMask(false);
      }

      push();
      translate(pos.x, pos.y, pos.z);
      rotateY(yaw);
      noStroke();
      texture(img);
      plane(w, h);
      pop();

      if (gl) gl.depthMask(true);
    },

    cameraRelativeMovement(){
      const cam = _renderer._curCamera;
      let forward = createVector(cam.centerX - cam.eyeX, 0, cam.centerZ - cam.eyeZ);
      if (forward.mag() === 0) forward = createVector(0,0,1);
      forward.normalize();
      let right = createVector(forward.z, 0, -forward.x);

      const speed = 3;
      let mv = createVector(0,0,0);

      if (keyIsDown(87) || keyIsDown(UP_ARROW)) mv.add(p5.Vector.mult(forward, speed));
      if (keyIsDown(83) || keyIsDown(DOWN_ARROW)) mv.sub(p5.Vector.mult(forward, speed));
      // corrigido: A ou LEFT_ARROW -> esquerda; D ou RIGHT_ARROW -> direita
      if (keyIsDown(68) || keyIsDown(RIGHT_ARROW)) mv.sub(p5.Vector.mult(right, speed));
      if (keyIsDown(65) || keyIsDown(LEFT_ARROW)) mv.add(p5.Vector.mult(right, speed));
      if (keyIsDown(32)) mv.y -= speed*2;

      return mv;
    },

    computeRotationIndexFor(move, state, ent){
        const cam = _renderer._curCamera;
        // unifica ordem de argumentos com drawBillboard: atan2(dx, dz)
        let angCam = degrees(atan2(cam.eyeX - ent.position.x, cam.eyeZ - ent.position.z));
        angCam = (angCam + 360) % 360;

        // se tem vetor de movimento válido, usa ele
        let useMove = (move && move.mag() > 0.001);
        let ang = angCam;

        if (useMove){
            // usa a mesma convenção de atan2 usada para a câmera (x, z)
            let angMove = degrees(atan2(move.x, move.z));
            angMove = (angMove + 360) % 360;
            // corrigido: ângulo relativo = movimento - câmera (não invertido)
            ang = (angMove - angCam + 360) % 360;
        }

        // encontra o índice mais próximo do DIRS
        let best = 0;
        let bestDiff = 1e9;
        for (let i=0;i<DIRS.length;i++){
            const dirAngle = DIRS[i] % 360;
            let diff = Math.abs(ang - dirAngle);
            if (diff > 180) diff = 360 - diff;
            if (diff < bestDiff){ bestDiff = diff; best = i; }
        }

        ent.lastFacingIndex = best;

        // aplica offset apenas se estiver em movimento
        if (useMove){
            const offsetDeg = STATE_ANGLE_OFFSETS[state] || 0;
            const offsetSteps = Math.round(offsetDeg / 45) % DIRS.length;
            best = (best + offsetSteps + DIRS.length) % DIRS.length;
        }

        return best;
        },

    resolveVerticalCollision(ent){
      let bestSurface = null;
      for (let c of this.cubes){
        const halfC = {x:c.size.x/2, y:c.size.y/2, z:c.size.z/2};
        const halfE = {x:ent.size.x/2, z:ent.size.z/2};
        if (ent.position.x + halfE.x > c.pos.x - halfC.x &&
            ent.position.x - halfE.x < c.pos.x + halfC.x &&
            ent.position.z + halfE.z > c.pos.z - halfC.z &&
            ent.position.z - halfE.z < c.pos.z + halfC.z){
          const surfaceY = c.pos.y - halfC.y - ent.size.y/2;
          if (surfaceY <= ent.position.y){
            if (bestSurface === null || surfaceY > bestSurface){
              bestSurface = surfaceY;
            }
          }
        }
      }

      if (bestSurface !== null){
        ent.position.y = bestSurface;
        ent.vel.y = 0;
        return;
      }

      if (ent.position.y >= GROUND_Y){
        ent.position.y = GROUND_Y;
        ent.vel.y = 0;
      }
    }
  };

  return world;
}


let world;

const DIRS = [360,45,90,135,180,225,270,315];
const STATE_ANGLE_OFFSETS = { idle: 90, run: 90, use: 0 }; // exposto globalmente para uso no draw()
const RUN_FRAMES = 5;
const USE_FRAMES = 3;

// --- preload p5.js ---
function preload(){
  world = world_new();
  world.images.player.idle = [[]]; // frame 0
  for (let i=0;i<DIRS.length;i++){
    world.images.player.idle[0][i] = safeLoad(`data/player/idle/0/png/${DIRS[i]}.png`);
  }

  // run frames
  world.images.player.run = [];
  for (let f=0; f<RUN_FRAMES; f++){
    world.images.player.run[f] = [];
    for (let i=0;i<DIRS.length;i++){
      world.images.player.run[f][i] = safeLoad(`data/player/run/${f}/png/${DIRS[i]}.png`);
    }
  }

  // use frames
  world.images.player.use = [];
  for (let f=0; f<USE_FRAMES; f++){
    world.images.player.use[f] = [];
    for (let i=0;i<DIRS.length;i++){
      world.images.player.use[f][i] = safeLoad(`data/player/use/${f}/png/${DIRS[i]}.png`);
    }
  }
}

function safeLoad(path){
  let img = loadImage(path, () => {}, () => { img = world.createPlaceholder(64,64); });
  return img;
}

// --- setup ---
function setup(){
  createCanvas(800,600,WEBGL);
  
  // cubos
  world.new_cube(createVector(400,-40,0), createVector(120,80,120));
  world.new_cube(createVector(-320,-40,160), createVector(100,120,100));
  world.new_cube(createVector(0,-40,480), createVector(60,60,60));

  // player
  world.new_creature({
    position: createVector(0,-40,0),
    state: "idle",
    npc: false
  });

  // NPC exemplo
  for (let i=0;i<3;i++){
    const spawn = createVector(random(-200,200), -40, random(-200,200));
    const target = createVector(random(-200,200), -40, random(-200,200));
    const dir = p5.Vector.sub(target, spawn).normalize();
    world.new_creature({
      position: spawn,
      npc: true,
      traveling: true,
      dirVec: dir,
      speed: 1.2,
      targetPos: target
    });
  }
}

function draw(){
    // input só pro primeiro (assumindo que é o player principal)
    if (world.creatures.length > 0) {
        const player = world.creatures[0];
        const movement = world.cameraRelativeMovement();
        if (movement.mag() > 0.001) {
            // apenas marca input e estado; atualização de posição/colisão será feita em updateCreature
            player._inputMoveVec = movement.copy();
            player.state = "run";
        } else {
            player.state = "idle";
            player.frame = 0;
            // remove qualquer input externo
            if (player._inputMoveVec) delete player._inputMoveVec;
        }
    }

    world.render();
}

</script>
</body>
</html>
